class TagSetRuntimeInformation {
  #tagSets;           // all registered tag sets
  #tags;              // all registered tags
  #undefinedTagSet;   // the placeholder tag set for all tags that have no tag set defined (i.e. tags with only an id)

  /**
   * Create a new instance to hold runtime information.
   */
  constructor() {
    // Set up TagSets
    this.#tagSets = new Map();
    this.#tags = new Map();
    // init undef. tag set
    this.#initializeUndefinedTagSet();
  }

  /**
   * Get all registered tag-sets.
   * @returns {Map<string,TagSet>}
   */
  get tagSets() {
    return this.#tagSets;
  }

  /**
   * Get all registered tags.
   * @returns {Map<string,Tag>}
   */
  get tags() {
    return this.#tags;
  }

  /**
   * Check if a TagSet for a given id exists.
   * @param {string} id the tagSet id 
   */
  hasTagSetForId(id) {
    return this.tagSets.has(id);
  }

  /**
   * Get a tagSet for a given id.
   * @param {string} id the tagSet id
   * @returns {Tag | undefined} the tagSet (if present)
   */
  getTagSetForId(id) {
    if (!this.#tagSets.has(id)) {
      console.warn('Tag with id not found: ', id);
    }
    return this.#tagSets.get(id);
  }
  
  /**
   * Check if a Tag for a given id exists.
   * @param {string} id the tag id 
   */
  hasTagForId(id) {
    return this.tags.has(id);
  }

  /**
   * Get a tag for a given id.
   * @param {string} id the tag id
   * @returns {Tag | undefined} the tag (if present)
   */
  getTagForId(id) {
    if (!this.#tags.has(id)) {
      console.warn('Tag with id not found: ', id);
    }
    return this.#tags.get(id);
  }

  /**
   * Initialize a unique TagSet for Tags that have no TagSet specified.
   */
  #initializeUndefinedTagSet() {
    let id, label, comment;
    // give a random id (not important, only valid during runtime)
    id = self.crypto.randomUUID();
    // set label and description
    label = "Undefined";
    comment = "TagSet for Tags where no TagSet is defiened";
    // save tag set
    this.#undefinedTagSet = new TagSet(id, [], label, comment);
    this.addNewTagSet(this.#undefinedTagSet);
  }

  /**
   * Export all tag sets and tags to a json file
   * @param {*} key 
   * @returns {Array<Tag|TagSet>} an array that can be converted to json containing all tags and tag sets
   */
  toJSON(key) {
    let array = [];
    // export TagSets
    for (let tagSet of this.tagSets.values()) {
      if (tagSet === this.#undefinedTagSet) {
        // don't export undefined TagSet
        continue;
      }
      if (tagSet.tags.length === 0) {
        // don't export empty TagSet
        continue;
      }
      array.push(tagSet);
    }
    // export tags
    for (let tag of this.tags.values()) {
      if (tag.tagSet === this.#undefinedTagSet) {
        // don't export tags belonging to the undefined tagset
        continue;
      }
      array.push(tag);
    }

    return array;
  }

  /**
   * Import a tag or tag set from json
   * @param {Object} obj the json object containing the tag or tag set
   */
  importFromJSON(obj) {
    if (!["http://sigmathling.kwarc.info/spotterbase/TagSet", "TagSet", "http://sigmathling.kwarc.info/spotterbase/Tag", "Tag"].includes(obj.type)) {
      return;
    }
    switch (obj.type) {
      case "http://sigmathling.kwarc.info/spotterbase/TagSet":
      case "TagSet":
        this.#addTagSetFromJSON(obj);
        break;
      case "http://sigmathling.kwarc.info/spotterbase/Tag":
      case "Tag":
        this.#addTagFromJSON(obj);
        break;
    }
  }

  /**
   * Add a new TagSet from JSON import.
   * @param {Object} obj json object
   */
  #addTagSetFromJSON(obj) {
    let tagSet;
    if (this.#tagSets.has(obj.id)) {
      // TagSet already present -> either autom. generated TagSet or duplicate
      tagSet = this.tagSets.get(obj.id);
      if (tagSet.autoGenerated) {
        // setup TagSet
        tagSet.label = obj.label;
        tagSet.comment = obj.comment;
        tagSet.autoGenerated = false;
      } else {
        console.warn('TagSet already present and will be skipped: ', tagSet);
        return;
      }
    } else {
      // create new TagSet
      tagSet = new TagSet(obj.id, [], obj.label, obj.comment, false);
      // save TagSet
      this.#tagSets.set(obj.id, tagSet);
    }
  }

  /**
   * Add a new Tag from JSON import.
   * @param {Object} obj json object
   */
  #addTagFromJSON(obj) {
    let tag, tagSet;
    if (this.tags.has(obj.id)) {
      // tag already present -> duplicate
      console.warn('Tag with id already present and will be skipped: ', this.#tags.get(obj.id));
      return;
    }
    tag = new Tag(obj.id, obj.label, obj.comment);
    // save tag
    this.tags.set(obj.id, tag);
    // get TagSet of Tag
    if (!this.tagSets.has(obj.belongsTo)) {
      // Tag import before TagSet -> auto generate
      tagSet = new TagSet(obj.belongsTo, [tag], "AutoGen", "Automatically generated TagSet.", true);
      this.tagSets.set(obj.belongsTo, tagSet);
    } else {
      tagSet = this.tagSets.get(obj.belongsTo);
      tagSet.addTag(tag);
    }
  }

  /**
   * Add a new TagSet.
   * @param {TagSet} tagSet the new TagSet
   */
  addNewTagSet(tagSet) {
    if (this.#tagSets.has(tagSet.id)) {
      console.error('Error: TagSet with id already exists', tagSet.id);
      return;
    }
    this.#tagSets.set(tagSet.id, tagSet);
  }

  /**
   * Add a new Tag.
   * @param {Tag} tag the new Tag
   * @param {string} belongsTo the TagSet id the Tag belongs to
   */
  addNewTag(tag, belongsTo) {
    let tagSet;
    if (!this.tagSets.has(belongsTo)) {
      console.error('Error: tagSet with id not found', belongsTo);
      return;
    }
    if (this.tags.has(tag.id)) {
      console.error('Error: Tag with id already exists', tag.id);
      return;
    }
    tagSet = this.tagSets.get(belongsTo);
    this.tags.set(tag.id, tag);
    tagSet.addTag(tag);
  }

  /**
   * Create a Tag with no further information.
   * @param {string} id the new Tag id
   * @returns {Tag} the newly created Tag
   */
  createTagForUndefinedTagSet(id) {
    let tag, color;
    if (this.tags.has(id)) {
      console.warn('Tag already present: ', id);
      return;
    }
    color = "#" + ((Math.random()*0xFFFFFF<<0).toString(16)).padStart(6, '0');
    tag = new Tag(id, "", "", color);
    this.addNewTag(tag, this.#undefinedTagSet.id);
    return tag;
  }

  /**
   * 
   * @param {Event} event the event that triggered
   * @param {string} id the Tag-ID to delete
   */
    deleteTagFromTagBody(event, id) {
      // TODO
    }
}

const tagSetPlugin = new TagSetRuntimeInformation();