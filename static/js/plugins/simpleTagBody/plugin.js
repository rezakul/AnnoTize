class SimpleTagBodyPlugin extends AnnotationPlugin {
  #tagSets;
  #tags;
  #undefinedTagSet;

  constructor() {
    super('SimpleTagBody', 'SimpleTagBody', 'SimpleTagBody', SimpleTagBody);
    this.supportUserCreation = true;
    this.supportUserEdit = true;
    // Set up TagSets
    this.#tagSets = new Map();
    this.#tags = new Map();
    this.#initializeUndefinedTagSet();
  }

  /**
   * Get all registered tag-sets.
   * @returns {Map<string,TagSet>}
   */
  get tagSets() {
    return this.#tagSets;
  }

  /**
   * Get all registered tags.
   * @returns {Map<string,Tag>}
   */
  get tags() {
    return this.#tags;
  }

  /**
   * Check if a TagSet for a given id exists.
   * @param {string} id the tagSet id 
   */
  hasTagSetForId(id) {
    return this.tagSets.has(id);
  }

  /**
   * Get a tagSet for a given id.
   * @param {string} id the tagSet id
   * @returns {Tag | null} the tagSet (if present)
   */
  getTagSetForId(id) {
    if (!this.#tagSets.has(id)) {
      console.warn('Tag with id not found: ', id);
      return null;
    }
    return this.#tagSets.get(id);
  }
  
  /**
   * Check if a Tag for a given id exists.
   * @param {string} id the tag id 
   */
  hasTagForId(id) {
    return this.tags.has(id);
  }

  /**
   * Get a tag for a given id.
   * @param {string} id the tag id
   * @returns {Tag | null} the tag (if present)
   */
  getTagForId(id) {
    if (!this.#tags.has(id)) {
      console.warn('Tag with id not found: ', id);
      return null;
    }
    return this.#tags.get(id);
  }

  /**
   * Initialize a unique TagSet for Tags that have no TagSet specified.
   */
  #initializeUndefinedTagSet() {
    let id, label, comment;
    id = self.crypto.randomUUID();
    label = "Undefined";
    comment = "TagSet for Tags where no TagSet is defiened";
    this.#undefinedTagSet = new TagSet(id, [], label, comment);
    this.addNewTagSet(this.#undefinedTagSet);
  }

  toJSON(key) {
    let array = [];
    // export TagSets
    for (let tagSet of this.tagSets.values()) {
      if (tagSet === this.#undefinedTagSet) {
        // don't export undefined TagSet
        continue;
      }
      if (tagSet.tags.length === 0) {
        // don't export empty TagSet
        continue;
      }
      array.push(tagSet);
    }
    // export tags
    for (let tag of this.tags.values()) {
      if (tag.tagSet === this.#undefinedTagSet) {
        // don't export tags belonging to the undefined tagset
        continue;
      }
      array.push(tag);
    }

    return array;
  }

  /**
   * Check if the plugin should be informed about the import of a certain type.
   * @param {string} type the json object type
   * @returns {boolean} true if plugin wants to be informed
   */
  informAboutImport(type) {
    return ["http://sigmathling.kwarc.info/spotterbase/TagSet", "TagSet", "http://sigmathling.kwarc.info/spotterbase/Tag", "Tag"].includes(type);
  }

  /**
   * Infomation about a import object.
   * @param {Object} obj 
   */
  importFromJSON(obj) {
    if (!["http://sigmathling.kwarc.info/spotterbase/TagSet", "TagSet", "http://sigmathling.kwarc.info/spotterbase/Tag", "Tag"].includes(obj.type)) {
      return;
    }
    switch (obj.type) {
      case "http://sigmathling.kwarc.info/spotterbase/TagSet":
      case "TagSet":
        this.#addTagSetFromJSON(obj);
        break;
      case "http://sigmathling.kwarc.info/spotterbase/Tag":
      case "Tag":
        this.#addTagFromJSON(obj);
        break;
    }
  }

  /**
   * Add a new TagSet from JSON import.
   * @param {Object} obj json object
   */
  #addTagSetFromJSON(obj) {
    let tagSet;
    if (this.#tagSets.has(obj.id)) {
      // TagSet already present -> either autom. generated TagSet or duplicate
      tagSet = this.tagSets.get(obj.id);
      if (tagSet.autoGenerated) {
        // setup TagSet
        tagSet.label = obj.label;
        tagSet.comment = obj.comment;
        tagSet.autoGenerated = false;
      } else {
        console.warn('TagSet already present and will be skipped: ', tagSet);
        return;
      }
    } else {
      // create new TagSet
      tagSet = new TagSet(obj.id, [], obj.label, obj.comment, false);
      // save TagSet
      this.#tagSets.set(obj.id, tagSet);
    }
  }

  /**
   * Add a new Tag from JSON import.
   * @param {Object} obj json object
   */
  #addTagFromJSON(obj) {
    let tag, tagSet;
    if (this.tags.has(obj.id)) {
      // tag already present -> duplicate
      console.warn('Tag with id already present and will be skipped: ', this.#tags.get(obj.id));
      return;
    }
    tag = new Tag(obj.id, obj.label, obj.comment);
    // save tag
    this.tags.set(obj.id, tag);
    // get TagSet of Tag
    if (!this.tagSets.has(obj.belongsTo)) {
      // Tag import before TagSet -> auto generate
      tagSet = new TagSet(obj.belongsTo, [tag], "AutoGen", "Automatically generated TagSet.", true);
      this.tagSets.set(obj.belongsTo, tagSet);
    } else {
      tagSet = this.tagSets.get(obj.belongsTo);
      tagSet.addTag(tag);
    }
  }

  /**
   * Add a new Annotation from JSON.
   * @param {object} annotation a json annotation object
   */
  addAnnotationFromJSON(annotation) {
    let body;
    if (!this.tags.has(annotation.body.val)) {
      // create Tag for Annotation
      this.createTagForUndefinedTagSet(annotation.body.val);
    }
    body = new SimpleTagBody(State.Display, this.tags.get(annotation.body.val));
    return body;
  }

  createTemplateFromJSON(json) {
    let template;
    let tag, tagSet;
            
    tag = json.tag;
    tagSet = json.tagSet;

    if (tag) {
      if (!this.hasTagForId(tag)) {
        // create the Tag
        console.warn('Unknown Tag-ID in Template: ', tag);
        tag = null;
      }
    }
    if (tagSet) {
      if (!this.hasTagSetForId(tagSet)) {
        // create the Tag
        console.warn('Unknown TagSet-ID in Template: ', tagSet);
        tagSet = null;
      }
    }

    template = new SimpleTagBodyTemplate(tagSet, tag);

    return template;
  }

  /**
   * Add a new TagSet.
   * @param {TagSet} tagSet the new TagSet
   */
  addNewTagSet(tagSet) {
    if (this.#tagSets.has(tagSet.id)) {
      console.error('Error: TagSet with id already exists', tagSet.id);
      return;
    }
    this.#tagSets.set(tagSet.id, tagSet);
  }

  /**
   * Add a new Tag.
   * @param {Tag} tag the new Tag
   * @param {string} belongsTo the TagSet id the Tag belongs to
   */
  addNewTag(tag, belongsTo) {
    let tagSet;
    if (!this.tagSets.has(belongsTo)) {
      console.error('Error: tagSet with id not found', belongsTo);
      return;
    }
    if (this.tags.has(tag.id)) {
      console.error('Error: Tag with id already exists', tag.id);
      return;
    }
    tagSet = this.tagSets.get(belongsTo);
    this.tags.set(tag.id, tag);
    tagSet.addTag(tag);
  }

  /**
   * Create a Tag with no further information.
   * @param {string} id the new Tag id
   * @returns {Tag} the newly created Tag
   */
  createTagForUndefinedTagSet(id) {
    let tag, color;
    if (this.tags.has(id)) {
      console.warn('Tag already present: ', id);
      return;
    }
    color = "#" + ((Math.random()*0xFFFFFF<<0).toString(16)).padStart(6, '0');
    tag = new Tag(id, "", "", color);
    this.addNewTag(tag, this.#undefinedTagSet.id);
    return tag;
  }

  /**
   * 
   * @param {Event} event the event that triggered
   * @param {string} id the Tag-ID to delete
   */
    deleteTagFromTagBody(event, id) {
      // TODO
    }
}

function initializeSimpleTagBodyPlugin() {
  let plugin;
  plugin = new SimpleTagBodyPlugin();
  plugin.registerPlugin();
  plugin.registerTemplate('SimpleTagBody', SimpleTagBodyTemplate);
}

// initializeSimpleTagBodyPlugin();


/** --------------------- New TagSet Class -------------------------------------------- */


class TagSetPlugin {
  #tagSets;
  #tags;
  #undefinedTagSet;

  constructor() {
    // Set up TagSets
    this.#tagSets = new Map();
    this.#tags = new Map();
    this.#initializeUndefinedTagSet();
  }

  /**
   * Get all registered tag-sets.
   * @returns {Map<string,TagSet>}
   */
  get tagSets() {
    return this.#tagSets;
  }

  /**
   * Get all registered tags.
   * @returns {Map<string,Tag>}
   */
  get tags() {
    return this.#tags;
  }

  /**
   * Check if a TagSet for a given id exists.
   * @param {string} id the tagSet id 
   */
  hasTagSetForId(id) {
    return this.tagSets.has(id);
  }

  /**
   * Get a tagSet for a given id.
   * @param {string} id the tagSet id
   * @returns {Tag | null} the tagSet (if present)
   */
  getTagSetForId(id) {
    if (!this.#tagSets.has(id)) {
      console.warn('Tag with id not found: ', id);
      return null;
    }
    return this.#tagSets.get(id);
  }
  
  /**
   * Check if a Tag for a given id exists.
   * @param {string} id the tag id 
   */
  hasTagForId(id) {
    return this.tags.has(id);
  }

  /**
   * Get a tag for a given id.
   * @param {string} id the tag id
   * @returns {Tag | null} the tag (if present)
   */
  getTagForId(id) {
    if (!this.#tags.has(id)) {
      console.warn('Tag with id not found: ', id);
      return null;
    }
    return this.#tags.get(id);
  }

  /**
   * Initialize a unique TagSet for Tags that have no TagSet specified.
   */
  #initializeUndefinedTagSet() {
    let id, label, comment;
    id = self.crypto.randomUUID();
    label = "Undefined";
    comment = "TagSet for Tags where no TagSet is defiened";
    this.#undefinedTagSet = new TagSet(id, [], label, comment);
    this.addNewTagSet(this.#undefinedTagSet);
  }

  toJSON(key) {
    let array = [];
    // export TagSets
    for (let tagSet of this.tagSets.values()) {
      if (tagSet === this.#undefinedTagSet) {
        // don't export undefined TagSet
        continue;
      }
      if (tagSet.tags.length === 0) {
        // don't export empty TagSet
        continue;
      }
      array.push(tagSet);
    }
    // export tags
    for (let tag of this.tags.values()) {
      if (tag.tagSet === this.#undefinedTagSet) {
        // don't export tags belonging to the undefined tagset
        continue;
      }
      array.push(tag);
    }

    return array;
  }

  /**
   * Infomation about a import object.
   * @param {Object} obj 
   */
  importFromJSON(obj) {
    if (!["http://sigmathling.kwarc.info/spotterbase/TagSet", "TagSet", "http://sigmathling.kwarc.info/spotterbase/Tag", "Tag"].includes(obj.type)) {
      return;
    }
    switch (obj.type) {
      case "http://sigmathling.kwarc.info/spotterbase/TagSet":
      case "TagSet":
        this.#addTagSetFromJSON(obj);
        break;
      case "http://sigmathling.kwarc.info/spotterbase/Tag":
      case "Tag":
        this.#addTagFromJSON(obj);
        break;
    }
  }

  /**
   * Add a new TagSet from JSON import.
   * @param {Object} obj json object
   */
  #addTagSetFromJSON(obj) {
    let tagSet;
    if (this.#tagSets.has(obj.id)) {
      // TagSet already present -> either autom. generated TagSet or duplicate
      tagSet = this.tagSets.get(obj.id);
      if (tagSet.autoGenerated) {
        // setup TagSet
        tagSet.label = obj.label;
        tagSet.comment = obj.comment;
        tagSet.autoGenerated = false;
      } else {
        console.warn('TagSet already present and will be skipped: ', tagSet);
        return;
      }
    } else {
      // create new TagSet
      tagSet = new TagSet(obj.id, [], obj.label, obj.comment, false);
      // save TagSet
      this.#tagSets.set(obj.id, tagSet);
    }
  }

  /**
   * Add a new Tag from JSON import.
   * @param {Object} obj json object
   */
  #addTagFromJSON(obj) {
    let tag, tagSet;
    if (this.tags.has(obj.id)) {
      // tag already present -> duplicate
      console.warn('Tag with id already present and will be skipped: ', this.#tags.get(obj.id));
      return;
    }
    tag = new Tag(obj.id, obj.label, obj.comment);
    // save tag
    this.tags.set(obj.id, tag);
    // get TagSet of Tag
    if (!this.tagSets.has(obj.belongsTo)) {
      // Tag import before TagSet -> auto generate
      tagSet = new TagSet(obj.belongsTo, [tag], "AutoGen", "Automatically generated TagSet.", true);
      this.tagSets.set(obj.belongsTo, tagSet);
    } else {
      tagSet = this.tagSets.get(obj.belongsTo);
      tagSet.addTag(tag);
    }
  }

  /**
   * Add a new TagSet.
   * @param {TagSet} tagSet the new TagSet
   */
  addNewTagSet(tagSet) {
    if (this.#tagSets.has(tagSet.id)) {
      console.error('Error: TagSet with id already exists', tagSet.id);
      return;
    }
    this.#tagSets.set(tagSet.id, tagSet);
  }

  /**
   * Add a new Tag.
   * @param {Tag} tag the new Tag
   * @param {string} belongsTo the TagSet id the Tag belongs to
   */
  addNewTag(tag, belongsTo) {
    let tagSet;
    if (!this.tagSets.has(belongsTo)) {
      console.error('Error: tagSet with id not found', belongsTo);
      return;
    }
    if (this.tags.has(tag.id)) {
      console.error('Error: Tag with id already exists', tag.id);
      return;
    }
    tagSet = this.tagSets.get(belongsTo);
    this.tags.set(tag.id, tag);
    tagSet.addTag(tag);
  }

  /**
   * Create a Tag with no further information.
   * @param {string} id the new Tag id
   * @returns {Tag} the newly created Tag
   */
  createTagForUndefinedTagSet(id) {
    let tag, color;
    if (this.tags.has(id)) {
      console.warn('Tag already present: ', id);
      return;
    }
    color = "#" + ((Math.random()*0xFFFFFF<<0).toString(16)).padStart(6, '0');
    tag = new Tag(id, "", "", color);
    this.addNewTag(tag, this.#undefinedTagSet.id);
    return tag;
  }

  /**
   * 
   * @param {Event} event the event that triggered
   * @param {string} id the Tag-ID to delete
   */
  deleteTagFromTagBody(event, id) {
    // TODO
  }
}

const tagSetPlugin = new TagSetPlugin();