class TagSet {
  #id;
  #tags;
  #label;
  #comment;
  #visibility;
  #autoGenerated;

  /**
   * Create a new tag-set containing tags of a semantic group.
   * @param {string} id the unique TagSet id
   * @param {Array<Tag>} tags tags for this TagSet
   * @param {string} label human readable label
   * @param {string} comment additional information
   * @param {boolean} auto indicates whether TagSet was automatically generated (import of Tag without TagSet)
   */
  constructor(id, tags, label, comment, auto=false) {
    this.#id = id;
    this.#tags = tags;
    for (let idx = 0; idx < tags.length; ++idx) {
      let tag = tags[idx];
      tag.register(this);
      if (tag.color === null) {
        tag.color = this.getColor(idx);
      }
    }
    // sort tags
    this.#tags.sort(this.#tagSortCmp);
    this.#label = label;
    this.#comment = comment;
    this.#visibility = true;
    this.#autoGenerated = auto;
  }

  /**
   * Unique TagSet id.
   */
  get id() {
    return this.#id;
  }

  set id(val) {
    this.#id = val;
  }

  /**
   * Human readable TagSet label.
   */
  get label() {
    return this.#label;
  }

  set label(val) {
    this.#label = val;
  }

  /**
   * Additional TagSet information.
   */
  get comment() {
    return this.#comment;
  }

  set comment(val) {
    this.#comment = val;
  }

  /**
   * All Tags belonging to this TagSet.
   */
  get tags() {
    return this.#tags;
  }

  get visibility() {
    return this.#visibility;
  }

  set visibility(val) {
    this.#visibility = val;
    for (let tag of this.tags) {
      tag.visibility = val;
    }
  }

  /**
   * Indicates whether TagSet was automatically generated.
   */
  get autoGenerated() {
    return this.#autoGenerated;
  }

  set autoGenerated(val) {
    this.#autoGenerated = val;
  }

  /**
   * Export this tagSet to json.
   * 
   * @param {any} key a key may given by JSON.stringify()
   * @returns {object} (JSON) stringifyable object
   */
  toJSON(key) {
    let json = {};
    let tags = [];

    json.type = "TagSet";
    json.id = this.id;
    for (let tag of this.#tags) {
      tags.push(tag.id);
    }
    json.belongsTo_Rev = tags;
    json.label = this.label;
    if (this.comment !== "") {
      json.comment = this.comment;
    }

    return json;
  }

  /**
   * Set the visibility of the TagSet without updating the child Tags.
   * @param {boolean} val set the visiblity to val 
   */
  setVisible(val) {
    this.#visibility = val;
  }

  /**
   * Add a new Tag to this TagSet
   * @param {Tag} tag the new Tag to add
   */
  addTag(tag) {
    tag.register(this);
    this.#tags.push(tag);
    // sort tags
    this.#tags.sort(this.#tagSortCmp);
  }

  getColor(idx) {
    let colors = [
      '#A3B9C9',  // powder blue
      '#EEE3AB',  // vanilla
      '#D9CFC1',  // bone
      '#FFBFB7',  // melon
      '#FFD447',  // mustard
      '#4ECDC4',  // robin egg blue
      '#59F8E8',  // fluorescent cyan
      '#90E0EF',  // non photo blue
      '#8FBC94',  // cambridge blue
      '#C3BF6D',  // citron
      '#DAFFED',  // mint green
      '#FFD4B8'   // apricot
    ]
    return idx < colors.length ? colors[idx] : '#941C2F';
  }

  /**
   * Internal Tag-Array sorter compare function.
   * @param {Tag} a 
   * @param {Tag} b 
   * @returns {boolean} according to asc. order
   */
  #tagSortCmp(a, b) {
    if (a.label && b.label) {
      return a.label.localeCompare(b.label);
    }
    return a.id.localeCompare(b.id);
  }
}

class Tag {
  #id;
  #color = null;
  #tagSet;
  #label;
  #comment;
  #visibility;
  #emitter;

  /**
   * A simple annotation Tag.
   * The tag has a value (id), and optional a label, comment.
   * The tag also defines a color in which the annotation is highlighted.
   * 
   * @param {string} id the tag id / value 
   * @param {string} label the tag label for better readability
   * @param {string} comment (optional) a comment with futher information regarding the tag
   * @param {string} color (optional) the color of the tag in a valid css format
   */
  constructor(id, label, comment="", color="") {
    this.#id = id;
    this.#label = label;
    this.#comment = comment;
    if (color != "") {
      this.#color = color;
    } else {
      this.#color = "#" + ((Math.random()*0xFFFFFF<<0).toString(16)).padStart(6, '0');
    }
    this.#visibility = true;
    this.#emitter = new EventTarget();
  }

  /**
   * The tag id / value.
   */
  get id() {
    return this.#id;
  }

  /**
   * The tag label.
   */
  get label() {
    return this.#label;
  }

  /**
   * The tag comment.
   */
  get comment() {
    return this.#comment;
  }

  /**
   * The tag color.
   */
  get color() {
    return this.#color;
  }

  set color(col) {
    if (col === this.#color) {
      return;
    }
    this.#color = col;
    // signal change
    this.emitter.dispatchEvent(new CustomEvent("change", {detail: { color: col, },}));
  }

  get emitter() {
    return this.#emitter;
  }

  /**
   * The tag-set this tag belongs to
   * @returns {TagSet}
   */
  get tagSet() {
    return this.#tagSet;
  }

  /**
   * The visability of the tag.
   * @returns {boolean}
   */
  get visibility() {
    return this.#visibility && this.tagSet.visibility;
  }

  set visibility(val) {
    this.#visibility = val;
    if (val === true) {
      this.tagSet.setVisible(true);
    }
  }

  /**
   * Export this tag to json.
   * 
   * @param {any} key a key may given by JSON.stringify()
   * @returns {object} (JSON) stringifyable object
   */
  toJSON(key) {
    let json = {};

    json.type = "Tag";
    json.id = this.id;
    json.belongsTo = this.tagSet.id;
    json.label = this.label;
    if (this.comment !== "") {
      json.comment = this.comment;
    }

    return json;
  }

  /**
   * Register a tag-set for this tag.
   * @param {TagSet} tagSet the tag-set of this tag
   */
  register(tagSet) {
    this.#tagSet = tagSet;
  }

  /**
   * Renders the tag as a html element.
   * @returns {Node} the tag as a html Node
   */
  renderTag() {
    let button;
    let luminance;

    button = document.createElement('button');
    
    button.setAttribute('class', 'annotation-tag-button');
    if (this.label) {
      button.textContent = this.label;
    } else {
      button.textContent = this.id;
    }
    
    button.style.backgroundColor = this.#color;
    luminance = computeLuminance(this.#color);
    if (luminance > 0.179) {
      button.style.color = '#000000';
    } else {
      button.style.color = '#ffffff';
    }
    button.dataset.tagId = this.id;
  
    button.addEventListener('click', runtime.showTagInformation);
    return button;
  }
}